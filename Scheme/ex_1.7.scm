; Реализация примера из книги

; Итерирующая функция, Ньютонов метод последовательных приближений
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
; Приближение
(define (improve guess x)
  (average guess (/ x guess)))

; Среднее арифметическое
(define (average x y)
  (/ (+ x y) 2))

; Предикат, определяющий достигло ли очередное приближение желаемой точности - разницы между квадратом найденного корня и исходным числом
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (square x)
  (* x x))

(define (sqrt x)
  (sqrt-iter 1.0 x))

; Уточненная версия предиката. В качестве критерия точности используется сравнение разницы между предыдущим приближением и текущим, с заданной долей самого приближения. Условно это можно назвать оценкой целесообразности дальнейших приближений - если разница между двумя приближениями уже достигла очень малого числа, то вычисление достигло установленной точности

(define (better-sqrt-iter prev-guess guess x)
  (if (better-good-enough? prev-guess guess)
      guess
      (better-sqrt-iter guess (improve guess x)
                        x)))

(define (better-good-enough? prev-guess guess)
  (< (abs (- prev-guess guess)) (* guess 0.001)))

(define (better-sqrt x)
  (better-sqrt-iter 1.0 2.0 x))

; Первоначальный способ обладает ужасной точностью на очень маленьких (меньше критерия точности) и очень больших (зависит от реализации чисел в машинном представлении) числах. Пример:

(sqrt 0.0004) ; => 0.0354008825558513
(better-sqrt 0.0004) ; => 0.020000000050981487

; В данном случае итерации приближений заканчиваются раньше, чем следует, т.к. разница квадрата найденного корня и первоначального числа получается меньше критерия точности, т.е. формально программа верна, ошибка в математической модели. Решить проблему можно увеличением точности (уменьшением критерия) на порядок:

;(define (good-enough? guess x)
;  (< (abs (- (square guess) x)) 0.0001))

;(sqrt 0.0004) ; => 0.02024031288207058

; Однако улучшенная версия предиката справляется с этой задачей самостоятельно - значение, достаточное, чтобы вычисления остановислись, определяется динамически

; С большими числами ситуация следующая:

;(sqrt 1000000000000) ; 1 000 000 000 000 вычисляется корректно => 1000000

;(sqrt 10000000000000) ; 10 000 000 000 000 отправляет программу в бесконечный цикл

; Причина в том, что разряды, на которых видна разница < 0.001, после возведения в квадрат отбрасываются из-за ограниченной длины чисел в машинном представлении. Пример:

;(define a 3162277.6601683795)
;(define b 3162277.6601456789)

;(< (abs (- a b)) 0.001) ; => #t

;(< (abs(- (square a) (square b))) 0.001) ; => #f

; Решить проблему можно уменьшением точности (увеличением критерия) на порядок:

;(define (good-enough? guess x)
;  (< (abs (- (square guess) x)) 0.01))

;(sqrt 10000000000000) ; => 3162277.6601683795

;(better-sqrt 10000000000000) ; вычисляется корректно в пределах математической модели и заданной точности => 3162277.6640104805














