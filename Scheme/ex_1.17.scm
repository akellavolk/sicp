; Данный алгоритм определяет операцию умножения через сложение

(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))

(* 21 14)

; При этом затрачивается число шагов пропорциональное b, т.е. порядок роста числа шагов линейно - R(n) = O(n). Чтобы привести данный алгоритм к логарифмическому росту числа шагов в учебнике предлагается опеределить дополнительные процедуры - удваивающую целое число и делящую четное число на 2.


(define (double a)
  (+ a a))

(define (halve a)
  (/ a 2))

(define (isEven a)
  (define (remainder a b)
    (- a (* (floor (/ a b)) b)))
  (= (remainder a 2) 0))

(define (fast* a b count)
  (cond ((or (= a 0) (= b 0)) 0)
        ((= b 1)
            (display count)
            (newline)
            a)
        ((isEven b) (double (fast* a (halve b) (+ count 1))))
        (else (+ a (double (fast* a (halve (- b 1)) (+ count 1)))))))

(fast* 3 128 0)

; Данная реализация затрачивает ровно log2(b) с округлением в меньшую сторону. Таким образом порядок роста числа шагов составляет R(n) = O(log(n)). Порядок роста требований к памяти линейный R(n) = O(n).