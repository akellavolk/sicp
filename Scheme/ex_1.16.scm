; Рекурсивный процесс возведения в степень с использованием последовательного возведения в квадрат

(define (remainder a b)
  (- a (* b (floor (/ a b)))))

(define (even? n)
  (= (remainder n 2) 0))

(define (square a)
  (* a a))

(define (fast-exp b n count)
  (cond ((= n 0)
            (display count)
            1)
        ((even? n) (square (fast-exp b (/ n 2) (+ count 1))))
        (else (* b (fast-exp b (- n 1) (+ count 1))))))

(fast-exp 2 1000 0)

(newline)

; Такой алгоритм возведения в степень очень быстр - возведение в 1000 степень потребует 15 вызовов процедуры fast-exp в которых выполнится 14 операций умножения - но все же обладает определенными требованиями к памяти. Чтобы уменьшить затраты памяти сделаем процесс итеративным. Для этого в учебнике предлагается использовать инвариант, который не меняется между шагами - (a*b)^n.

(define (better-fast-exp b n count a)
  (cond ((= n 0)
            (display count)
            a)
          ((even? n) (fast-exp (square b) (/ n 2) (+ count 1) a))
          (else (fast-exp b (- n 1) (+ count 1) (* a b)))))

(better-fast-exp 2 800 0 1)

; Данная реализация алгоритма с использованием последовательного возведения в квадрат по прежнему остается очень быстрой, но при этом требования к памяти остаются неизменными (если мы отбрасываем вопрос размера перемножаемых чисел) R(n) = O(1)